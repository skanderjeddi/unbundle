//! GIF export integration tests.
//!
//! These tests require the fixture files generated by
//! `tests/fixtures/generate_fixtures.sh` (or `.bat` on Windows).

#![cfg(feature = "gif")]

use std::path::Path;

use unbundle::{FrameRange, GifOptions, MediaFile};

fn sample_video_path() -> &'static str {
    "tests/fixtures/sample_video.mp4"
}

#[test]
fn gif_export_to_memory() {
    let path = sample_video_path();
    if !Path::new(path).exists() {
        return;
    }

    let mut unbundler = MediaFile::open(path).expect("open");
    let config = GifOptions::default().width(160);
    let gif_bytes = unbundler
        .video()
        .export_gif_to_memory(FrameRange::Range(0, 5), &config)
        .expect("gif export");

    assert!(!gif_bytes.is_empty());
    // GIF files start with "GIF89a" or "GIF87a".
    assert_eq!(&gif_bytes[..3], b"GIF", "expected GIF header");
}

#[test]
fn gif_export_to_file() {
    let path = sample_video_path();
    if !Path::new(path).exists() {
        return;
    }

    let output = "tests/fixtures/test_output.gif";
    let mut unbundler = MediaFile::open(path).expect("open");
    let config = GifOptions::default().width(80);
    unbundler
        .video()
        .export_gif(output, FrameRange::Range(0, 3), &config)
        .expect("gif export to file");

    assert!(Path::new(output).exists());
    let data = std::fs::read(output).expect("read gif");
    assert_eq!(&data[..3], b"GIF");
    std::fs::remove_file(output).ok();
}

#[test]
fn gif_config_builder() {
    let config = GifOptions::default().width(320).frame_delay(50).repeat(None);
    assert_eq!(config.width, Some(320));
    assert_eq!(config.frame_delay, 50);
    assert!(config.repeat.is_none());
}
