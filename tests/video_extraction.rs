//! Video extraction integration tests.
//!
//! These tests require the fixture files generated by
//! `tests/fixtures/generate_fixtures.sh` (or `.bat` on Windows).

use std::{path::Path, time::Duration};

use unbundle::{FrameRange, MediaUnbundler};

/// Path to the standard test video fixture (5s, 640×480, 30 fps, with audio).
fn sample_video_path() -> &'static str {
    "tests/fixtures/sample_video.mp4"
}

/// Skip the test if the fixture file does not exist.
fn require_fixture(path: &str) {
    if !Path::new(path).exists() {
        eprintln!(
            "Skipping test: fixture '{path}' not found. \
             Run tests/fixtures/generate_fixtures.sh first."
        );
        return;
    }
}

#[test]
fn extract_first_frame() {
    let path = sample_video_path();
    require_fixture(path);
    if !Path::new(path).exists() {
        return;
    }

    let mut unbundler = MediaUnbundler::open(path).expect("Failed to open test video");
    let frame = unbundler
        .video()
        .frame(0)
        .expect("Failed to extract first frame");

    // Verify dimensions match metadata.
    let video_metadata = unbundler.metadata().video.as_ref().unwrap();
    assert_eq!(frame.width(), video_metadata.width);
    assert_eq!(frame.height(), video_metadata.height);
}

#[test]
fn extract_frame_by_timestamp() {
    let path = sample_video_path();
    if !Path::new(path).exists() {
        return;
    }

    let mut unbundler = MediaUnbundler::open(path).expect("Failed to open test video");
    let frame = unbundler
        .video()
        .frame_at(Duration::from_secs(2))
        .expect("Failed to extract frame at 2s");

    let video_metadata = unbundler.metadata().video.as_ref().unwrap();
    assert_eq!(frame.width(), video_metadata.width);
    assert_eq!(frame.height(), video_metadata.height);
}

#[test]
fn extract_frame_range() {
    let path = sample_video_path();
    if !Path::new(path).exists() {
        return;
    }

    let mut unbundler = MediaUnbundler::open(path).expect("Failed to open test video");
    let frames = unbundler
        .video()
        .frames(FrameRange::Range(0, 9))
        .expect("Failed to extract frame range");

    assert!(
        !frames.is_empty(),
        "Expected at least one frame from range 0..9"
    );
    assert!(
        frames.len() <= 10,
        "Expected at most 10 frames from range 0..9, got {}",
        frames.len()
    );
}

#[test]
fn extract_frames_by_interval() {
    let path = sample_video_path();
    if !Path::new(path).exists() {
        return;
    }

    let mut unbundler = MediaUnbundler::open(path).expect("Failed to open test video");
    let frames = unbundler
        .video()
        .frames(FrameRange::Interval(30))
        .expect("Failed to extract interval frames");

    // 5 seconds at 30 fps = 150 frames; every 30th = at least 5 frames.
    assert!(
        !frames.is_empty(),
        "Expected at least one frame from interval extraction"
    );
}

#[test]
fn extract_frames_by_time_range() {
    let path = sample_video_path();
    if !Path::new(path).exists() {
        return;
    }

    let mut unbundler = MediaUnbundler::open(path).expect("Failed to open test video");
    let frames = unbundler
        .video()
        .frames(FrameRange::TimeRange(
            Duration::from_secs(1),
            Duration::from_secs(2),
        ))
        .expect("Failed to extract time range frames");

    assert!(
        !frames.is_empty(),
        "Expected frames in the 1s–2s time range"
    );
}

#[test]
fn extract_frames_by_time_interval() {
    let path = sample_video_path();
    if !Path::new(path).exists() {
        return;
    }

    let mut unbundler = MediaUnbundler::open(path).expect("Failed to open test video");
    let frames = unbundler
        .video()
        .frames(FrameRange::TimeInterval(Duration::from_secs(1)))
        .expect("Failed to extract time interval frames");

    // 5 seconds → frames at 0s, 1s, 2s, 3s, 4s, 5s → up to 6 frames.
    assert!(
        frames.len() >= 4,
        "Expected at least 4 frames at 1-second intervals, got {}",
        frames.len()
    );
}

#[test]
fn extract_specific_frames() {
    let path = sample_video_path();
    if !Path::new(path).exists() {
        return;
    }

    let mut unbundler = MediaUnbundler::open(path).expect("Failed to open test video");
    let frames = unbundler
        .video()
        .frames(FrameRange::Specific(vec![0, 30, 60]))
        .expect("Failed to extract specific frames");

    assert!(
        !frames.is_empty(),
        "Expected frames for specific frame numbers"
    );
}

#[test]
fn frame_out_of_range_returns_error() {
    let path = sample_video_path();
    if !Path::new(path).exists() {
        return;
    }

    let mut unbundler = MediaUnbundler::open(path).expect("Failed to open test video");
    let result = unbundler.video().frame(999_999);

    assert!(
        result.is_err(),
        "Expected error for out-of-range frame number"
    );
}

#[test]
fn frame_dimensions_match_metadata() {
    let path = sample_video_path();
    if !Path::new(path).exists() {
        return;
    }

    let mut unbundler = MediaUnbundler::open(path).expect("Failed to open test video");
    let video_metadata = unbundler.metadata().video.clone().unwrap();
    let frame = unbundler
        .video()
        .frame(10)
        .expect("Failed to extract frame 10");

    assert_eq!(frame.width(), video_metadata.width);
    assert_eq!(frame.height(), video_metadata.height);
}

#[test]
fn no_video_stream_returns_error() {
    let path = "tests/fixtures/sample_audio_only.mp4";
    if !Path::new(path).exists() {
        return;
    }

    let mut unbundler = MediaUnbundler::open(path).expect("Failed to open audio-only file");
    let result = unbundler.video().frame(0);

    assert!(result.is_err(), "Expected NoVideoStream error");
}

#[test]
fn video_only_file_works() {
    let path = "tests/fixtures/sample_video_only.mp4";
    if !Path::new(path).exists() {
        return;
    }

    let mut unbundler = MediaUnbundler::open(path).expect("Failed to open video-only file");
    assert!(unbundler.metadata().video.is_some());
    assert!(unbundler.metadata().audio.is_none());

    let frame = unbundler
        .video()
        .frame(0)
        .expect("Failed to extract frame from video-only file");
    assert!(frame.width() > 0);
    assert!(frame.height() > 0);
}
