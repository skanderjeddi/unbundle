//! Video stream-copy integration tests.
//!
//! These tests require fixture files generated by
//! `tests/fixtures/generate_fixtures.sh` (or `.bat` on Windows).

use std::{path::Path, time::Duration};

use unbundle::{MediaFile, UnbundleError};

fn sample_video_path() -> &'static str {
    "tests/fixtures/sample_video.mp4"
}

#[test]
fn stream_copy_video_to_file() {
    let path = sample_video_path();
    if !Path::new(path).exists() {
        return;
    }

    let output = tempfile::NamedTempFile::new().expect("Failed to create temp file");
    let output_path = output.path().with_extension("mp4");

    let mut unbundler = MediaFile::open(path).expect("Failed to open test video");
    unbundler
        .video()
        .stream_copy(&output_path)
        .expect("Failed to stream-copy video to file");

    let written_bytes = std::fs::read(&output_path).expect("Failed to read output file");
    assert!(
        !written_bytes.is_empty(),
        "Expected non-empty output after video stream copy"
    );

    let _ = std::fs::remove_file(&output_path);
}

#[test]
fn stream_copy_video_range_to_file() {
    let path = sample_video_path();
    if !Path::new(path).exists() {
        return;
    }

    let output = tempfile::NamedTempFile::new().expect("Failed to create temp file");
    let output_path = output.path().with_extension("mp4");

    let mut unbundler = MediaFile::open(path).expect("Failed to open test video");
    unbundler
        .video()
        .stream_copy_range(
            &output_path,
            Duration::from_millis(500),
            Duration::from_secs(2),
        )
        .expect("Failed to stream-copy video range to file");

    let written_bytes = std::fs::read(&output_path).expect("Failed to read output file");
    assert!(
        !written_bytes.is_empty(),
        "Expected non-empty range output after video stream copy"
    );

    let _ = std::fs::remove_file(&output_path);
}

#[test]
fn stream_copy_video_to_memory() {
    let path = sample_video_path();
    if !Path::new(path).exists() {
        return;
    }

    let mut unbundler = MediaFile::open(path).expect("Failed to open test video");
    let bytes = unbundler
        .video()
        .stream_copy_to_memory("matroska")
        .expect("Failed to stream-copy video to memory");

    assert!(
        !bytes.is_empty(),
        "Expected non-empty in-memory payload after video stream copy"
    );
}

#[test]
fn stream_copy_video_invalid_range_returns_error() {
    let path = sample_video_path();
    if !Path::new(path).exists() {
        return;
    }

    let mut unbundler = MediaFile::open(path).expect("Failed to open test video");
    let result = unbundler.video().stream_copy_range(
        "unused.mp4",
        Duration::from_secs(2),
        Duration::from_secs(1),
    );

    assert!(result.is_err(), "Expected invalid range error");
    assert!(
        matches!(result.unwrap_err(), UnbundleError::InvalidRange { .. }),
        "Expected InvalidRange variant"
    );
}
